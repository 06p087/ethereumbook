[[ens_chapter]]
== Ethereum Name Service (ENS)

In chapter <<keys-addresses>> we looked at how Ethereum accounts are referenced in the Ethereum protocol: namely, using the last 20 bytes of the keccak256 hash of the public key, which we tend to pass around as 40 digit hexadecimal strings, such as +0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9+. This is not a very human-friendly format, being practically impossible to remember and very error prone to type in. Copy-paste only helps us so far - without a check-sum to protect against mistakes, it's very easy to lose ether by sending it to addresses with no owner to be inaccessable forever. This design decision was made with the thought that user-friendliness would be added in higher layers built on top of the base platform protocol. In this chapter we look at one implementation of exactly that higher layer infrastructure: the *Ethereum Name Service*, also called simply *ENS*.

The fundamental problem is providing human-friendly labels for otherwise incomprehensible identifiers. As an example, the *Ethereum Foundation* donation contract address is +0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359+ which is not in any way memorable ot easy to write down or type in. However, with an alias service, such as ENS, it's simply +ethereum.eth+, which is very easy to remember and type. This isn't a new problem - we have the same problem on the world wide web; for instance +91.198.174.192+ is the IP address of Wikipedia, but is not an address you are going to remember. On the traditional IP-based internet, this was solved by the *Domain Naming system (DNS)*, which is a hierarchical system ultimately centralized on *ICANN*, a US-based organization that controls the distribution of top level domains, like +.com+ or +.org+.

Ethereum provides an attempt to solve the same problem but in a _decentralized manner_: the *Ethereum Naming System (ENS)* is a smart contract running in the secure environment of the Ethereum platform. In a wallet that supports ENS, sending or receiving funds can be done much more conveniently with aliases, like +ethereum.org+ rather than +0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359+, with the mapping being secured by the trustless security of Ethereum.

Address aliases are not the only feature of ENS. In fact, any abstract identifier can be given a human-readable label, which has wide-ranging infrastructure simplifying advantages beyond just sending and receiving ether and tokens. For example, let's look at running a DApp: you can design the best smart contract in the world, but if you don't provide a good interface for users, they won't be able to access it. As we have seen, contracts on Ethereum can be considered the backend of your application, and you can write the front-end in any language or framework you feel comfortable with. Most of the DApps you'll read about in this book currently use a traditional server model to serve that front-end, but if you want to truly decentralize your application, you can also use decentralized hosting services like bit torrent, *Swarm* or *IPFS* to also host the files required for the *front-end*. These services differ from server-based data stores by having the data objects addressed by a content-derived identifier. In a traditional server model of the web, you access content by describing the address where you can find the content. For instance +91.198.174.192+ is the IP address of Wikipedia, but those numbers have no information on what sort of content you will find, only the routing information of the computers that will serve you wikipedia's content. Content-addressing systems are different in that their addresses reflect the content itself, not the "location" - in fact, in a distributed, decentralized system, the notion of "location" could well be meaningless. For instance, with just the content hash +QmfXeApFP1mCrMTT1JX5XLtUvLxS5eNsegqDpBYUZPhXEQ+ you can obtain an image of a penguin from any computer on the IPFS network. Different standards, like *IPFS* or *Swarm* will likely have different hashes, but they all address data objects solely using identifiers deverived from the content itself. This allows more flexibility and decentralization because, as long as a single node in your network has a copy of that image (or is connected to a node that has a copy of it), you can access it. This process allows for any files (including html, javascript, css, images, etc) that will make up your interface, to be accessed in a decentralized manner. However, this content hash based approach has a huge drawback: the identifiers are not very human friendly - they consist of large mumbles of letters and numbers, which are neither memorable nor easy to type, just like Ethereum addresses, but more likely even worse.

Alias services, such as ENS, can really help by providing concise, descriptive and human-friendly labels for otherwise incomprehensible identifiers of both any data object and any account address.


=== Name resolution services

* What is a name resolution service?
* Why another one?
* Why are they needed (addresses, contracts, swarm objects, etc.)
* Benefits (security, disambiguation, redirection/upgrade, readability/user experience)
* Concerns about squatting, trademarks, dispute resolution

=== History of Ethereum name services

Name registrations was the first non-currency application of blockchains, being pioneered by *Namecoin*. However, Namecoin was another blockchain in and of itself, adding to the feeling that a general purpose blockchain was needed to avoid the situation where every application we could think of for blockchain technology had its own, most likely insecure, blockchain. The Ethereum whitepaper was so enthusiastically welcomed in part because it provided a solution, complete with a "namecoin" service written in just three lines of code as one of the example aplications, being obviously simplier and more secure than an entirely new and separate blockchain.

The early releases of geth and CPP client had a standard default *namereg* contract (which is no longer in use) and many proposals and ERCs have existed since the beginning, but it was not before Nick Johnson started working for Ethereum Foundation in 2016 and took the project under his wing that work on a serious registrar started.

ENS was launched on Star Wars day, May 4, 2017 (after a failed attempt of launching it on Pie Day, march 15) and it was immediately open for registrations.

=== The ENS specification

ENS is specified mainly in three *Ethereum Improvement Proposals (EIPs)*, namely *EIP137* which specifies the high level, overall functionality and organization of the Ethereum Name Service, *EIP162* in which an initial design for the fundamental component for name allocations, the *registrar*, is described, and *EIP181* for reverse resolution of addresses to the aliases that have been registered for them.

ENS follows a *sandwich* design philosophy: a very simple layer on the bottom, followed by layers of more complex but *replaceable code*, followed with a very simple top layer.

The base layer is the *registry*, which simply handles the mapping from names to some basic information, most importantly the owner of each name and how to find out what the name represents.

The middle layers handle all the machinery, including name *resolution* (i.e. what each name represents, such as ethereum addresses), *registration* of name ownership (e.g. through public decentralized auctions), and *reverse lookups* (e.g. for answering the question, "who am I paying?", i.e. for finding the owners if all you have is an ethereum address).

The top layer is there to administer the holding of deposited funds. Holding Ether value is a big deal, because if there is a bug in the smart contract code, the Ether could be lost forever. As such, it is prudent to keep value-holding smart contracts as simple as possible to minimize the possibility of a bug. Ether is used by the ENS system to determine who can own which names, and it is locked up for the duration of the ownership period. When ownership is lost (by expiry or otherwise), the deposit is returned.

=== Bottom of the sandwich: Names and Name Owners

The base layer of the sandwich is fully described in *EIP137*. There are two key concepts that are fixed at this base layer:

1. Names are arranged hierarchically, in the same way as domain names on the internet, with top-level domain names "owning" sub-domains, and sub-domains "owning" sub-sub-domains, etc, written out in reverse order, e.g. +subdomain.example.eth+

2. Each domain name (at any level) has an owner. The owner is allowed to tag information to their name and create and manage sub-domains. 

The base layer is required to implement a small number of functions: to enable a name owner to set information about their own name (specifically the resolver, time to live or transferring the ownership); and to create owners of new sub-domains.

The ENS system actually operates on identifier hashes of names, called *nodes*, instead of the human-readable names directly. To create a node identifer hash, the human readable name is converted using the *namehash recursive algorithm*.

==== Namehash algorithm

+namehash+ is a recursive algorithm that converts any ENS name into an *identifier hash* of that name, which we call a *node*. By using hashes instead of the actual names, the ENS system works faster and with lower memory requirements, because no matter how long a name is, or how many levels of sub-domain it has, the hash is always the same length. 

The algorithm works by taking a name and spliting it in two: the lowest level label (i.e. the first one), plus the rest. The hash is taken of the first part and the rest is +namedhash+ed in the same way. The output is the hash of the concatination of these two. If +namehash+ is asked to process nothing, it returns +0+.

Let's look at our example +subdomain.example.eth+:

....
namehash('subdomain.example.eth') = sha3( namehash('example.eth') + sha3('subdomain') )
*with*
namehash('example.eth') = sha3( namehash('eth') + sha3('example') )
*and*
namehash('eth') = sha3( namehash('') + sha3('eth') )
*and, importantly*
namehash('') = 0
....

It should be noted that the namehash process also includes a UTS46 normalization transform before each label is hashed.

In a more concise way we can describe the +namehash+ function as follows:

....
namehash('') = 
0x0000000000000000000000000000000000000000000000000000000000000000
namehash('label.remainder') = sha3( namehash('remainder') + sha3(UTS46_normalize('label')) )
....

Or in Python:

....
def namehash(name):
  if name == '':
    return '\0' * 32
  else:
    label, _, remainder = name.partition('.')
    label = UTS46_normalize(label)
    return sha3(namehash(remainder) + sha3(label))
....

Thus, *mastering-ethereum.eth* will be processed as follows;

....
node = sha3(node1 + sha3('mastering-ethereum'))
node1 = sha3(node0 + sha3('eth'))
node0 = '\0' * 32
....

You might ask how many levels can an ENS name have? Can we have +sub.subdomain.example.eth+, or +sub.sub.subdomain.example.eth+, etc? Well, the answer is simply, yes! If an owner wants to create sub-domains beneath their label, they can, irrespective of the level their label sits at. Allowing this is partly the motivation for +namehash+ and its precomputation of names into nodes. The smart contracts running the on-chain part of the ENS infrastructure are naturally restricted in the amount of processing they can do, so by having an off-chain conversion to a fixed length identifier, we can have efficient processing of names of any length or sub-label depth.

==== How to choose a valid name
We have been building up what an ENS name looks like, but we can describe it quite concisely: an ENS name is a series of *dot-separated labels*.

Although _upper and lower case_ letters in principle are allowed, all labels should follow a *UTS46* normalisation process that case-folds labels before hashing them, so names with different case but identical spelling will end up with the _same namehash_.

You could use labels and domains of _any length_, but for the sake of compatibility with legacy *DNS*, the following is recommended:

* Labels be restricted to *no more than 64 characters* each.
* Complete ENS names to *no more than 255 characters*.
* Labels *do not start or end* with *hyphens*, or *start* with *digits*.

==== Rootnode ownership

One of the results of this hierarchical system is that it relies on the owners of the *rootnode* to create top level domains (TLDs).

While the eventual goal is to move rootnode ownership into some sort of decentralized decision making process for new TLDs, right now the rootnode is a *4 out of 7 multisig*, held by people in different countries; built as a reflection of the seven keyholders of the DNS system. As a result, a majority of at least 4 of the 7 keyholders is required to effect any change at the top level of the Ethereum name hierarchy.

Currently, the purpose and goal of these keyholders is to work in consensus with the community to:

* Migrate and upgrade the temporary ownership of the +.eth+ TLD to a more permanent contract once the system is evaluated.
* Allow the adding new TLDs, if the community agrees that such is ever needed.
* Migrate the ownership of the root multisig to a more decentralized contract, when such system is agreed upon, tested and implemented.
* To serve as a last resort way to deal with any bugs or vulnerability in the top level registries.

==== Resolvers

The base level of ENS is only concerned with what names exist and who owns them. It does not deal with associating metadata with the names: that is the job of the *Resolver Contracts*.

The ENS system has been architected in this modular way to allow more flexibility by allowing users to create custom contracts to answer any questions about a given name. Questions that might be answered in those such as "what's the swarm address associated with this app?", "What is the ethereum address that receives payments in ERC20 tokens?", "What's the hash of the app, in order to verify its integrity?", and so forth.

=== Middle layer: the +.eth+ domain names

At the moment, the only top level domain (label) that is available is +.eth+.

There's work on enabling traditional DNS domain owners to claim ENS ownership of there internet domain names, but this is a tricky process. The idea is that the likes of +.com+ TLDs can be resolved on the Ethereum platform, but the only DNS domain that has been registered so far is +.xyz+ and only on the Ethereum testnet. More information here - +https://medium.com/the-ethereum-name-service/how-to-claim-your-dns-domain-on-ens-e600ef2d92ca+.

Sub-domains of +.eth+ are created and allocated via a nomination and auction system. To help avoid controvosy, new labels directly beneath the +.eth+ TLD much be at least seven characters long. There are no special _reserved lists_ or _exclusive priorities_, and the only way to acquire a name is to use the same system as everyone else.

The smart contract code required for auctioning names is necessarily more complex than for the base layer registry, and most of the bugs and tests on the development phase were here. This is way the "sandwich" architecture has been adopted; exactly because this more complex middle layer code is replaceable and upgradeable (without risks to the funds – more on that later).

==== Vickrey Auctions

The way +.eth+ names are distributed is via a *Vickrey Auction*. This is a blind auction that attempts to find the bidder with the higher expected utility for the name, but without exagerating the value.
Since there are no profits gathered from the auctions, there's no incentive to maximize it.

In a traditional Vickrey auction, every bidder submits a sealed bid, and all of them are revealed during the reveal period, at which point the person with the highest bid wins the auction, but only pays the second highest price.

Therefore bidders are incentivized in putting down their theoretical maximum utility value for a domain, since increasing it increases the chance they will win but does not affect the price they will eventually pay: they only need to pay enough to outbid the second higher bidder.

On a blockchain, some changes are required;

* Since you don't have everyone on the same room legally binding them to their promises, then bidders MUST to lock up a value equal or higher than their bid beforehand, to guarantee the bid is valid.
* Because you can't hide secrets on a blockchain, bidders MUST execute at least two transactions, a 'commit' and then a 'reveal', in order to hide the original value and name they bid on.
* Since you can't reveal all bids at the same time on a decentralized manner bidders MUST reveal their own bids themselves or be punished by losing their funds if they don't.

Note that if such punishment did not exist, one could make multiple bids in many price points and choose to only reveal a few strategically important ones, therefore turning a sealed-bid auction in a traditional increasing price auction.

As such, the auction process has four steps:

1. *Start the auctions*. This is a required step to broadcast the intent to register names.

This creates all auction deadlines. The names are hashed, so that only those who have the name in their dictionary will know which auction was opened. This allows some privacy, specially if you are creating a new project and don't want to share details about it. It is possible to open multiple "dummy" hashes at the same time, so if someone is following you, they cannot simply bid on all auctions you open.

2. *Collect sealed bids*. All bid must be made before the bidding deadline. 

A bid is placed by tying up a given amount of ether to a hash of a secret message. The message contains, among other things, the hash of the name, the actual amount of the bid, and a salt. Bidders can lock up more ether than is actually needed in order to mask the real evaluation.

3. *Reveal the bids*. During the reveal period, bidders must make a transaction that reveals the bid.

The smart contract will then calculate the highest bidder and the second highest bid value. Because the resolution must be decentralized, every time a bid is revealed the current winner is recalculated. The last one to be set before the revealing deadline expires, becomes the owner.

4. *Finalization*: if you are the owner, you can *finalize* the auction.

This is in order to get back the difference between _your bid and the second higher one_. If you forgot to reveal you can make a late reveal and recover a small amount of the original value.

==== Top layer of the sandwich: the Deeds

The last layer is another super simple contract with a single purpose: to *hold the funds*.

When you *win* a name, the funds are not actually sent anywhere, but are just locked up for the period you want to hold the name (minimum of a year). This works like a guarantee buy-back model, where, if the owner does not want the name anymore they can sell it back to the system and get their ether back, In this way, the "rent" for owning a name is the opportunity cost of having the ether locked up.

But of course, having a single contract hold millions of dollars in ether has proven to be very risky, so instead ENS solves that by creating a *Deed Contract* for each new name. The Deed Contract is a very simple smart contract and it only allows the funds to be transferred back to a single account (the deed owner) and to be called by a single entity (the registrar contract). This approach drastically reduces the attack surface which can put the funds at risk.

=== Registering a name
.ENS timeline for registration
image::images/ens-flow.png[]

////
Image with permission from Chris Remus, Nick Johnson and Alex Van de Sande, via article by Chris Remus
////

=== Resolving a name

In ENS, resolving a name, is a two-step process:

1. First, the ENS registry is called with the name to resolve (after hashing it using the namehash algorithm). If the record exists, the registry returns the address of its resolver.

2. Then, the resolver is called, using the method appropriate to the resource being requested. The resolver then returns the desired result.

=== Setting an ENS name resolver

==== Types of resolvers

==== Address resolver

==== Smart contract resolver

==== Swarm object resolver

=== ENS subdomains

==== Creating a subdomains

=== ENS secondary markets

==== Buying and selling names

==== Renting a name

=== Conclusion


Links:

https://ens.domains/

https://mycrypto.com/#ens

https://manager.ens.domains/

https://registrar.ens.domains/

https://github.com/ethereum/ens/

https://docs.ens.domains/
